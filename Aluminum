getgenv().aluminum = {
    ["Enabled"] = true,
    ["AimPart"] = "UpperTorso",
    ["Prediction"] = 0.18339333333333335,
    ["Smoothness"] = 0.139,
    ["ShakeValue"] = 0,
    ["AutPred"] = true,
    ["Loaded"] = false,
    ["AutoReload"] = false,
    ["TTKO"] = false,
    ["AntiAimViewer"] = true,
    ["AutoReload"] = true,
    ["cframe"] = {
        ["enabled"] = false,
        ["speed"] = 2
    },
    ["TargetStrafe"] = {
        ["Enabled"] = false,
        ["StrafeSpeed"] = 10,
        ["StrafeRadius"] = 7,
        ["StrafeHeight"] = 3,
        ["RandomizerMode"] = false
    },
    ["targetaim"] = {
        ["Toggled"] = false,
        ["AutoShoot"] = false,
        ["enabled"] = true,
        ["targetPart"] = "UpperTorso",
        ["prediction"] = 0.18339333333333335
    },
    ["Triggerbot"] = {
        ["ClosestPart"] = {
            ["HitParts"] = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart", "RightFoot", "LeftFoot"}
        },
        ["FOV"] = {
            ["Enabled"] = true,
            ["Size"] = 13,
            ["Centered"] = false,
            ["Visible"] = true,
            ["Filled"] = false,
            ["Color"] = Color3.fromRGB(255, 0, 0)
        },
        ["Settings"] = {
            ["Prediction"] = 0.111,
            ["ClickDelay"] = 0.1,
            ["ActivationDelay"] = 2,
            ["IgnoreFriends"] = false,
            ["AutomaticallyFire"] = false
        },
        ["Resolver"] = {
            ["Enabled"] = true,
            ["Method"] = "RecalculateVelocity",
            ["Prediction Settings"] = {
                ["HitPart"] = "Head"
            },
            ["desync"] = {
                ["sky"] = false,
                ["invis"] = true,
                ["jump"] = false,
                ["network"] = false
            },
            ["Misc"] = {
                ["LowGfx"] = false
            },
            ["FPSunlocker"] = {
                ["Enabled"] = true,
                ["FPSCap"] = 999
            }
        }
    }
}

local RS = game:GetService("RunService")

local ScreenGui = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local TextButton = Instance.new("TextButton")
    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")

    ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    Frame.Parent = ScreenGui
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 1
    Frame.Position = UDim2.new(1, -120, 0, 0)
    Frame.Size = UDim2.new(0, 100, 0, 50)

    TextButton.Parent = Frame

    TextButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextButton.BackgroundTransparency = 1.000
    TextButton.Size = UDim2.new(1, 0, 1, 0)
    TextButton.Font = Enum.Font.SourceSans
    TextButton.Text = "Menu"
    TextButton.TextColor3 = Color3.fromRGB(105, 105, 105)
    TextButton.TextScaled = true
    TextButton.TextSize = 30
    TextButton.TextStrokeColor3 = Color3.fromRGB(255, 255, 255)
    TextButton.TextStrokeTransparency = 0.000
    TextButton.TextWrapped = true
    TextButton.MouseButton1Down:Connect(
        function()
            Library:Toggle()
        end
    )

    UITextSizeConstraint.Parent = TextButton
    UITextSizeConstraint.MaxTextSize = 30

    local player = game.Players.LocalPlayer

   
    local function onCharacterAdded(character)
        ScreenGui.Parent = player.PlayerGui
    end

    local function connectCharacterAdded()
        player.CharacterAdded:Connect(onCharacterAdded)
    end

   
    connectCharacterAdded()

   
    player.CharacterRemoving:Connect(
        function()
            ScreenGui.Parent = nil
        end
    )


local repo = 'https://raw.githubusercontent.com/LionTheGreatRealFrFr/MobileLinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()




local Window =
        Library:CreateWindow(
        {
            Title = "Aluminum",
            Center = true,
            AutoShow = true
        }
    )

    local Tabs = {
        Main = Window:AddTab("Legit"),
        Rage = Window:AddTab("HvH"),
        Visuals = Window:AddTab("Visuals"),
        ["UI Settings"] = Window:AddTab("UI Settings")
    }



local Tool = Tabs.Main:AddLeftGroupbox("tool")

local Cam = Tabs.Main:AddLeftGroupbox("Camlock")

local Res = Tabs.Main:AddLeftGroupbox("Resolver")

local Tar = Tabs.Main:AddRightGroupbox("target aim")

local Tri = Tabs.Main:AddRightGroupbox("trigger bot")

local cframe = Tabs.Rage: AddRightGroupbox("Speed")

local TargetStrafe = Tabs.Rage: AddLeftGroupbox("Target strafe")

local Fov = Tabs.Visuals: AddLeftGroupbox("Fov")



Cam:AddToggle(
        "Enable Camlock",
        {
            Text = "Enable camlock",
            Default = true,
            Tooltip = "Enable",
            Callback = function(state)
             aluminum.Enabled = state
            end 
        }
    )

Cam:AddToggle(
        "Enable ttko",
        {
            Text = "Enable ttko",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               aluminum.TTKO = state
            end
        }
    ) 

Cam:AddToggle(
        "Enable autopred",
        {
            Text = "Enable autopred",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               aluminum.AutoPred = state
            end
        }
    ) 



Cam:AddInput(
        "Prediction",
        {
            Default = "Prediction",
            Numeric = false,
            Finished = false,
            Text = "Prediction",
            Tooltip = "Change Prediction For Target",
            Placeholder = "0.16",
            Callback = function(value)
                aluminum.Prediction = value
            end
        }
    )
    

Cam:AddInput(
        "Smoothness",
        {
            Default = "smoothness",
            Numeric = false,
            Finished = false,
            Text = "smoothness",
            Tooltip = "Change smoothing For Target",
            Placeholder = "0.9",
            Callback = function(value)
                aluminum.Smoothness = value
            end
        }
    )

Cam:AddInput(
        "Shake",
        {
            Default = "Shake",
            Numeric = false,
            Finished = false,
            Text = "shake ",
            Tooltip = "Change shake For Target",
            Placeholder = "0",
            Callback = function(value)
                aluminum.ShakeValue = value
            end
        }
    )

Cam:AddDropdown(
        "Hitpart",
        {
            Values = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg",  "LeftUpperLeg", "RightLowerLeg", "RightFoot",  "RightUpperLeg"},
            Default = 1,
            Multi = false,
            Text = "Hitpart",
            Tooltip = "Choose the hit part",
            Callback = function(value)
                aluminum.AimPart = value
            end
        }
    )

Tar:AddToggle(
        "Enable TargetAim",
        {
            Text = "Enable targetaim",
            Default = true,
            Tooltip = "Enable",
            Callback = function(state)
               targetaim.enabled = state
            end
        }
    )
    
Tar:AddToggle(
        "AutoShoot",
        {
            Text = "AutoShoot",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
            targetaim.AutoShoot = state
            end
        }
    )

Tar:AddInput(
        "Prediction",
        {
            Default = "Prediction",
            Numeric = false,
            Finished = false,
            Text = "Prediction",
            Tooltip = "Change Prediction For Target",
            Placeholder = "0.1355",
            Callback = function(value)
                targetaim.prediction = value
            end
        }
    )
    

Tar:AddToggle(
        "Enable autopred",
        {
            Text = "Enable autopred",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               targetaim.AutoPred = state
            end
        }
    ) 

Tar:AddDropdown(
        "Hitpart",
        {
            Values = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg",  "LeftUpperLeg", "RightLowerLeg", "RightFoot",  "RightUpperLeg"},
            Default = 1,
            Multi = false,
            Text = "Hitpart",
            Tooltip = "Choose the hit part",
            Callback = function(value)
                targetaim.targetPart = value
            end
        }
    )
Tar:AddToggle(
        "Enable AutoReload",
        {
            Text = "Enable AutoReload",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               aluminum.AutoReload = state
            end
        }
    ) 


Res:AddToggle(
        "Enable Resolver",
        {
            Text = "Enable resolver",
            Default = true,
            Tooltip = "Enable",
            Callback = function(state)
             aluminum.Resolver.Enabled = state
            end 
        }
    )

Res:AddDropdown(
        "Resolver",
        {
            Values = {"RecalculateVelocity"},
            Default = 1,
            Multi = false,
            Text = "Resolver Mode",
            Tooltip = "Choose the resolving method",
            Callback = function(value)
                aluminum.Resolver.Method = value
            end
        }
    )


Tri:AddToggle(
        "Enable TriggerBot",
        {
            Text = "Enable TriggerBot",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               aluminum.Triggerbot.Settings["Automatically Fire"] = state
            end
        }
    )

Tri:AddInput(
        "Click delay",
        {
            Default = "click delay",
            Numeric = false,
            Finished = false,
            Text = "click delay",
            Tooltip = "Change delay For Clicks",
            Placeholder = "0.1",
            Callback = function(value)
                aluminum.Triggerbot.Settings["Click Delay"] = value
            end
        }
    )

Tri:AddInput(
        "activation delay",
        {
            Default = "activation delay",
            Numeric = false,
            Finished = false,
            Text = "click delay",
            Tooltip = "Change delay For Clicks",
            Placeholder = "3",
            Callback = function(value)
                aluminum.Triggerbot.Settings["Activation Delay"] = value
            end
        }
    )




TargetStrafe:AddToggle(
        "Target Strafe",
        {
            Text = "Target Strafe",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
                aluminum.TargetStrafe.Enabled = state
            end
        }
    )

TargetStrafe:AddToggle(
        "Target Strafe randomiser",
        {
            Text = "Target Strafe randomiser",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
                aluminum.TargetStrafe.RandomizerMode = state
            end
        }
    )



TargetStrafe:AddSlider(
    "Target speed",
    {
        Text = "How fast you spin around target",
        Default = 0,
        Min = 0,
        Max = 50,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            aluminum.TargetStrafe.StrafeSpeed = Value
        end
    }
)

TargetStrafe:AddSlider(
    "Target radius",
    {
        Text = "How far you are around target",
        Default = 0,
        Min = 0,
        Max = 50,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            aluminum.TargetStrafe.StrafeRadius = Value
        end
    }
)

TargetStrafe:AddSlider(
    "Target height",
    {
        Text = "How heigh you are from the target",
        Default = 0,
        Min = 0,
        Max = 50,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            aluminum.TargetStrafe.StrafeHeight = Value
        end
    }
)




cframe:AddToggle(
        "Enable cframe",
        {
            Text = "Enable cframe",
            Default = false,
            Tooltip = "Enable",
            Callback = function(state)
               aluminum.cframe.enabled = state
            end
        }
    )

cframe:AddSlider(
    "cframe speed",
    {
        Text = "How fast you run around ",
        Default = 0,
        Min = 0,
        Max = 50,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            aluminum.cframe.Speed = Value
        end
    }
)



Tool:AddButton(
    "Create tool",
    function()
       spawnTool()
    end
)

Tool:AddButton(
    "Create Button",
    function()
       spawnButton()
    end
)

Tool:AddButton(
    "Controller (dpad up)",
    function()
       setupController()
    end
)



local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('aluminumlua')
SaveManager:SetFolder('aluminumlua/configs')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()









loadstring(Game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/refs/heads/main/Source.lua", true))()

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Function to create the FOV circle
local function createFOVCircle()
    local circle = Drawing.new("Circle")
    circle.Thickness = 1
    circle.Color = aluminum.Triggerbot.FOV.Color
    circle.Filled = aluminum.Triggerbot.FOV.Filled
    circle.Visible = aluminum.Triggerbot.FOV.Enabled
    return circle
end

local FOVCircle = createFOVCircle()

-- Function to update the FOV circle's position and size
local function updateFOVCircle()
    if aluminum.Triggerbot.FOV.Enabled then
        FOVCircle.Radius = aluminum.Triggerbot.FOV.Size
        FOVCircle.Visible = true

        if aluminum.Triggerbot.FOV["Centered FOV"] then
            FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        else
            local mousePos = UserInputService:GetMouseLocation()
            FOVCircle.Position = mousePos
        end
    else
        FOVCircle.Visible = false
    end
end

-- Function to validate if the target is valid
local function isTargetValid(player)
    return player and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0
end

-- Function to get the closest player to the mouse or FOV center
local function getMouseTarget()
    local mousePos = aluminum.Triggerbot.FOV["Centered FOV"] 
                     and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) 
                     or UserInputService:GetMouseLocation()
    local closestPlayer = nil
    local closestDistance = aluminum.Triggerbot.FOV.Size

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isTargetValid(player) then
            for _, hitPartName in ipairs(aluminum.Triggerbot.ClosestPart.HitParts) do
                local hitPart = player.Character and player.Character:FindFirstChild(hitPartName)
                if hitPart then
                    local partPos = Camera:WorldToViewportPoint(hitPart.Position)
                    local distance = (Vector2.new(partPos.X, partPos.Y) - mousePos).Magnitude

                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

-- Function to fire at the selected target
local function fireAtTarget(target)
    if target then
        local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if Tool and Tool:FindFirstChild("Handle") then
            Tool:Activate()
            task.wait(aluminum.Triggerbot.Settings["Click Delay"])
            Tool:Deactivate()
        end
    end
end

-- Function to get the closest player using advanced calculations
local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestScore = math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and isTargetValid(plr) then
            local part = plr.Character[aluminum.AimPart]
            if part then
                local relativePos = part.Position - Camera.CFrame.Position
                local playerDistance = relativePos.Magnitude
                local screenPosition, onScreen = Camera:WorldToViewportPoint(part.Position)

                if onScreen then
                    local angle = math.deg(math.acos(Camera.CFrame.LookVector:Dot(relativePos.Unit)))
                    local mouseDistance = (Vector2.new(screenPosition.X, screenPosition.Y) - UserInputService:GetMouseLocation()).Magnitude

                    local angleFactor = angle / 90
                    local distanceFactor = playerDistance / 1000

                    local score = mouseDistance * 0.3 + angleFactor * 0.5 + distanceFactor * 0.2

                    local ray = Ray.new(Camera.CFrame.Position, relativePos.Unit * playerDistance)
                    local hitPart = Workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})

                    if (not hitPart or hitPart:IsDescendantOf(plr.Character)) and score < shortestScore then
                        closestPlayer = plr
                        shortestScore = score
                    end
                end
            end
        end
    end

    return closestPlayer
end



local userInputService = game:GetService("UserInputService")

local AimlockState = true
local Locked = false
local Victim
local target

if aluminum.Loaded then
    Library:Notify('Already Loaded')
    return
end

aluminum.Loaded = true

local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local userInputService = game:GetService("UserInputService")

-- Function for the "Tool" mode
function spawnTool()
    local Tool = Instance.new("Tool")
    Tool.RequiresHandle = false
    Tool.Name = "."
    Tool.Parent = player.Backpack

    local function onCharacterAdded()
        Tool.Parent = player.Backpack
    end

    player.CharacterAdded:Connect(onCharacterAdded)

    player.CharacterRemoving:Connect(function()
        Tool.Parent = player.Backpack
    end)

    Tool.Activated:Connect(function()
        ToggleLock()
    end)
end

-- Function for the "Button" mode
function spawnButton()
    local function setupGui()
        local screenGui = playerGui:FindFirstChild("LockScreenGui")

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Name = "LockScreenGui"
            screenGui.Parent = playerGui
        end

        local button = screenGui:FindFirstChild("LockButton")

        if not button then
            button = Instance.new("TextButton")
            button.Name = "LockButton"
            button.Size = UDim2.new(0, 100, 0, 50)
            button.Position = UDim2.new(0.5, 1279, 0.8, 817)
            button.Text = "â€¢"
            button.TextSize = 30
            button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Parent = screenGui
            button.Active = true
            button.Draggable = true

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 25)
            UICorner.Parent = button

            button.MouseButton1Click:Connect(function()
                ToggleLock()
            end)
        end
    end

    setupGui()

    player.CharacterAdded:Connect(function()
        setupGui()
    end)
end

-- Function for the "Controller" mode
function setupController()
    userInputService.InputBegan:Connect(function(input, processed)
        if not processed then
            if input.KeyCode == Enum.KeyCode.DPadUp then
                ToggleLock()
            end
        end
    end)
end

RS.RenderStepped:Connect(function()
    if AimlockState and Victim and Victim.Character and Victim.Character:FindFirstChild(aluminum.AimPart) then
        local aimPart = Victim.Character[aluminum.AimPart]
        local targetPosition = aimPart.Position + aimPart.Velocity * aluminum.Prediction
        local lookPosition = CFrame.new(Camera.CFrame.p, targetPosition)
        Camera.CFrame = Camera.CFrame:Lerp(lookPosition, aluminum.Smoothness)

        if aluminum.TargetStrafe.Enabled then
            local lp = player.Character
            local targpos = Victim.Character.HumanoidRootPart.Position
            local strafeOffset
            
            if aluminum.TargetStrafe.RandomizerMode then
               
                strafeOffset = Vector3.new(
                    math.random(-aluminum.TargetStrafe.StrafeRadius, aluminum.TargetStrafe.StrafeRadius),
                    math.random(0, aluminum.TargetStrafe.StrafeHeight),
                    math.random(-aluminum.TargetStrafe.StrafeRadius, aluminum.TargetStrafe.StrafeRadius)
                )
            else
               
                strafeOffset = Vector3.new(
                    math.cos(tick() * aluminum.TargetStrafe.StrafeSpeed) * aluminum.TargetStrafe.StrafeRadius,
                    aluminum.TargetStrafe.StrafeHeight,
                    math.sin(tick() * aluminum.TargetStrafe.StrafeSpeed) * aluminum.TargetStrafe.StrafeRadius
                )
            end

           
            local strafePosition = targpos + strafeOffset
            strafePosition = Vector3.new(strafePosition.X, math.max(strafePosition.Y, targpos.Y), strafePosition.Z)
            
            lp:SetPrimaryPartCFrame(CFrame.new(strafePosition))
            player.Character.HumanoidRootPart.CFrame = CFrame.new(
                player.Character.HumanoidRootPart.CFrame.Position,
                Vector3.new(targpos.X, player.Character.HumanoidRootPart.CFrame.Position.Y, targpos.Z)
            )
        end
    end
end)

spawn(function()
    RS.Heartbeat:Connect(function()
        if aluminum.Enabled and aluminum.cframe.enabled then
            player.Character.HumanoidRootPart.CFrame =
                player.Character.HumanoidRootPart.CFrame + player.Character.Humanoid.MoveDirection * aluminum.cframe.speed
        end
    end)
end)

for _, con in pairs(getconnections(Camera.Changed)) do
    con:Disable()
end
for _, con in pairs(getconnections(Camera:GetPropertyChangedSignal("CFrame"))) do
    con:Disable()
end

local mt = getrawmetatable(game)
local oldNameCall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(Self, ...)
    local args = {...}
    local methodName = getnamecallmethod()
    if not checkcaller() and methodName == "FireServer" and aluminum.targetaim.enabled then
        for i, Argument in ipairs(args) do
            if typeof(Argument) == "Vector3" and target and target.Character then
                args[i] = target.Character[aluminum.targetaim.targetPart].Position + (target.Character[aluminum.targetaim.targetPart].Velocity * aluminum.targetaim.prediction)
                return oldNameCall(Self, unpack(args))
            end
        end
    end
    return oldNameCall(Self, ...)
end)

setreadonly(mt, true)

while task.wait() do
    if aluminum.TTKO and Victim and Victim.Character and Victim.Character:FindFirstChild("Humanoid") then
        if Victim.Character.Humanoid.Health <= 2 then
            local chatEvents = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
            if chatEvents and chatEvents:FindFirstChild("SayMessageRequest") then
                local sayMessageRequest = chatEvents.SayMessageRequest
                if sayMessageRequest and sayMessageRequest:IsA("RemoteEvent") then
                    sayMessageRequest:FireServer("tap in w aluminum lua bro", "All")
                    wait(0.6)
                    sayMessageRequest:FireServer("ur dirt btw", "All")
                elseif sayMessageRequest and sayMessageRequest:IsA("RemoteFunction") then
                    sayMessageRequest:InvokeServer("tap in w aluminum lua bro", "All")
                    wait(0.6)
                    sayMessageRequest:InvokeServer("ur dirt btw", "All")
                end
            end
        end
    end
end

while task.wait() do
    if aluminum.Enabled and aluminum.AutoPred then
        local pingValue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local ping = tonumber((pingValue:match("%d+")))
        if ping then
            if ping > 225 then
                aluminum.Prediction = 0.21966833333333335
            elseif ping > 215 then
                aluminum.Prediction = 0.21966833333333335
            elseif ping > 205 then
                aluminum.Prediction = 0.21214
            elseif ping > 190 then
                aluminum.Prediction = 0.21214
            elseif ping > 185 then
                aluminum.Prediction = 0.20474833333333334
            elseif ping > 180 then
                aluminum.Prediction = 0.20474833333333334
            elseif ping > 175 then
                aluminum.Prediction = 0.19749333333333333
            elseif ping > 170 then
                aluminum.Prediction = 0.19749333333333333
            elseif ping > 165 then
                aluminum.Prediction = 0.190375
            elseif ping > 160 then
                aluminum.Prediction = 0.190375
            elseif ping > 155 then
                aluminum.Prediction = 0.18339333333333335
            elseif ping > 150 then
                aluminum.Prediction = 0.18339333333333335
            elseif ping > 145 then
                aluminum.Prediction = 0.17654833333333333
            elseif ping > 140 then
                aluminum.Prediction = 0.17654833333333333
            elseif ping > 135 then
                aluminum.Prediction = 0.16984
            elseif ping > 130 then
                aluminum.Prediction = 0.16984
            elseif ping > 120 then
                aluminum.Prediction = 0.16326833333333332
            elseif ping > 110 then
                aluminum.Prediction = 0.15683333333333335
            elseif ping > 105 then
                aluminum.Prediction = 0.15053500000000003
            elseif ping > 100 then
                aluminum.Prediction = 0.15053500000000003
            elseif ping > 90 then
                aluminum.Prediction = 0.14437333333333335
            elseif ping > 80 then
                aluminum.Prediction = 0.14437333333333335
            elseif ping > 70 then
                aluminum.Prediction = 0.13834833333333335
            elseif ping > 60 then
                aluminum.Prediction = 0.13246
            elseif ping > 50 then
                aluminum.Prediction = 0.12670833333333334
            elseif ping > 40 then
                aluminum.Prediction = 0.12670833333333334
            elseif ping > 30 then
                aluminum.Prediction = 0.11561500000000001
            elseif ping > 20 then
                aluminum.Prediction = 0.11027333333333333
            elseif ping > 10 then
                aluminum.Prediction = 0.10087127181718181
            elseif ping < 10 then
                aluminum.Prediction = 0.100871271817181811332
            else
                aluminum.Prediction = 0.1008
            end
        end
      end
    end
        

aluminum.AntiGroundShots = true

if aluminum.AntiGroundShots then
    AimPoint = aluminum.AimPart.Position + Vector3.new(aluminum.AimPart.Velocity.X, (aluminum.AimPart.Velocity.Y * 0.5), aluminum.AimPart.Velocity.Z) * prediction
else
    AimPoint = aluminum.AimPart.Position + aluminum.AimPart.Velocity * prediction
end


while aluminum.AutoReload == true and game:GetService("RunService").Heartbeat:Wait() do
if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
            if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo") then
                if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo").Value <= 0 then
                    game:GetService("ReplicatedStorage").MainEvent:FireServer("Reload", game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool")) 
                    wait(1)
                end
            end
        end
end



if aluminum.desync.sky == true then
    getgenv().aluminumSky = true 
    getgenv().SkyAmount = 90

    game:GetService("RunService").Heartbeat:Connect(function()
        if getgenv().aluminumSky then 
            local vel = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, getgenv().SkyAmount, 0) 
            game:GetService("RunService").RenderStepped:Wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = vel
        end
    end)
end

if aluminum.desync.jump == true then
    getgenv().jumpanti = true
    
    game:GetService("RunService").Heartbeat:Connect(function()
        if getgenv().jumpanti then    
            local CurrentVelocity = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(1000, 1000, 1000)
            game:GetService("RunService").RenderStepped:Wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = CurrentVelocity
        end
    end)
end

if aluminum.desync.jump == true then

-- Maximum Roblox velocity (128^2 or 16384)
local velMax = (128 ^ 2)

local timeRelease, timeChoke = 0.015, 0.105

local Property, Wait = sethiddenproperty, task.wait
local Radian, Random, Ceil = math.rad, math.random, math.ceil
local Angle = CFrame.Angles
local Vector = Vector3.new
local Service = game.GetService

local Run = Service(game, 'RunService')
local Stats = Service(game, 'Stats')
local Players = Service(game, 'Players')
local LocalPlayer = Players.LocalPlayer
local statPing = Stats.PerformanceStats.Ping
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Root = Character:WaitForChild("HumanoidRootPart")
local Mouse = LocalPlayer:GetMouse()

local runRen, runBeat = Run.RenderStepped, Run.Heartbeat
local runRenWait, runRenCon = runRen.Wait, runRen.Connect
local runBeatCon = runBeat.Connect

local function Ping()
    return statPing:GetValue()
end

local function Sleep()
    Property(Root, 'NetworkIsSleeping', true)
end

local function FireGun()
    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("Shoot") then
        local ShootEvent = tool.Shoot
        ShootEvent:FireServer(Mouse.Hit.Position)
    end
end

local function Init()
    if not Root then return end

    local rootVel = Root.Velocity
    local rootCFrame = Root.CFrame

   
    local rootAng = Random(-180, 180)
    local rootOffset do
        local X = Random(-velMax, velMax)
        local Y = Random(0, velMax)
        local Z = Random(-velMax, velMax)
        rootOffset = Vector(X, -Y, Z)
    end

    Root.CFrame = Angle(0, Radian(rootAng), 0)
    Root.Velocity = rootOffset

   
    FireGun()


    runRenWait(runRen)
    Root.CFrame = rootCFrame
    Root.Velocity = rootVel
end

runBeatCon(runBeat, Init)

-- Main loop for choking replication
while Wait(timeRelease) do
    -- Stable replication packets
    local chokeClient, chokeServer = runBeatCon(runBeat, Sleep), runRenCon(runRen, Sleep)

    Wait(Ceil(Ping()) / 1000)

    chokeClient:Disconnect()
    chokeServer:Disconnect()

end
end

if aluminum.desync.network == true then
local RunService = game:GetService("RunService")

local function onHeartbeat()
    setfflag("S2PhysicsSenderRate", 1)
end

RunService.Heartbeat:Connect(onHeartbeat)
end

if aluminum.Misc.LowGfx == true then
game:GetService("CorePackages").Packages:Destroy()
end

if aluminum.FPSunlocker.Enabled then
    setfpscap(aluminum.FPSunlocker.FPSCap)
end

if aluminum.AntiAimViewer == true then

--// Services
local aluminum = setmetatable({}, {
    __index = function(_, service)
        return game:GetService(service)
    end
})

local Players, ReplicatedStorage = aluminum.Players, aluminum.ReplicatedStorage
local LocalPlayer, Mouse = Players.LocalPlayer, Players.LocalPlayer:GetMouse()
local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

--// Bypass Function
local function Bypass(entity)
    entity.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            child.Activated:Connect(function()
                if MainEvent then
                    MainEvent:FireServer("UpdateMousePos", Mouse.Hit.Position)
                end
            end)
        end
    end)
end

--// Check if Player is Alive
local function IsAlive(player)
    local character = player and player.Character
    return character and character:FindFirstChild("Humanoid") and character:FindFirstChild("Head")
end

--// Setup Bypass for Local Player
LocalPlayer.CharacterAdded:Connect(Bypass)
if IsAlive(LocalPlayer) then
    LocalPlayer.Character.Humanoid:UnequipTools()
    Bypass(LocalPlayer.Character)
end

--// Hook Metamethod
local Hook
Hook = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}
    if not checkcaller() and getnamecallmethod() == "FireServer" and self.Name == "MainEvent" and args[1] == "UpdateMousePos" then
        args[2] = Mouse.Hit.Position
        return self.FireServer(self, unpack(args))
    end
    return Hook(self, ...)
end)
end

local lastPosition = nil
local lastUpdateTime = tick()

local function resolveTargetVelocity(target)
    if getgenv().aluminum.Resolver.Enabled then
        if getgenv().aluminum.Resolver.Method == "RecalculateVelocity" then
            local currentTime = tick()
            local deltaTime = currentTime - lastUpdateTime

            if lastPosition then
                local resolvedVelocity = (target.Character[getgenv().aluminum.Resolver["Prediction Settings"].HitPart].Position - lastPosition) / deltaTime
                lastPosition = target.Character[getgenv().aluminum.Resolver["Prediction Settings"].HitPart].Position
                lastUpdateTime = currentTime
                return resolvedVelocity
            else
                lastPosition = target.Character[getgenv().aluminum.Resolver["Prediction Settings"].HitPart].Position
                lastUpdateTime = currentTime
            end
        end
    end
    return target.Character[getgenv().aluminum.Resolver["PredictionSettings"].HitPart].Velocity
end

while aluminum.AutoReload == true and game:GetService("RunService").Heartbeat:Wait() do
if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
            if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo") then
                if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo").Value <= 0 then
                    game:GetService("ReplicatedStorage").MainEvent:FireServer("Reload", game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool")) 
                    wait(1)
                end
            end
        end
end
